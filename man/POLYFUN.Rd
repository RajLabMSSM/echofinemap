% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/POLYFUN.R
\name{POLYFUN}
\alias{POLYFUN}
\title{Run PolyFun+SUSIE fine-mapping pipeline}
\source{
\href{https://www.nature.com/articles/s41588-020-00735-5}{
PolyFun publication}

\href{https://github.com/omerwe/polyfun}{
PolyFun GitHub repo}
}
\usage{
POLYFUN(
  dat,
  LD_matrix,
  locus_dir,
  polyfun = NULL,
  mode = c("precomputed", "parametric", "non-parametric"),
  method = c("SUSIE", "FINEMAP"),
  dataset_type = "GWAS",
  max_causal = 5,
  compute_n = "ldsc",
  credset_thresh = 0.95,
  rescale_priors = TRUE,
  conda_env = "echoR_mini",
  force_new = FALSE,
  nThread = 1,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{dat}{Fine-mapping results data.}

\item{mode}{PolyFun can run in several different modes corresponding 
to how SNP-wise prior causal probabilities (i.e. priors) are computed:
\itemize{
\item{"precomputed" : }{
Using precomputed prior causal probabilities based on a meta-analysis of 
15 UK Biobank traits. The meta-analysis was performed as part of the 
original \href{https://www.nature.com/articles/s41588-020-00735-5}{
PolyFun publication}.}

\item{"parametric" : }{
Computing prior causal probabilities via an L2-regularized extension of 
stratified LD-score regression (S-LDSC). This is a relatively simple 
approach, but the prior causal probabilities may not be robust to modeling
 misspecification.
Gathered from the "*.snpvar_ridge_constrained.gz" output files from PolyFun}.

\item{"non-parametric" : }{
Computing prior causal probabilities non-parametrically. 
This is the most robust approach, but it is computationally intensive and
 requires access to individual-level genotypic data from a large reference 
 panel (optimally >10,000 population-matched individuals).
Gathered from the "*.snpvar_constrained.gz" output files from PolyFun}.
}}

\item{max_causal}{The maximum number of non-zero effects 
(and thus causal variants).}

\item{compute_n}{How to compute per-SNP sample size (new column "N").
\itemize{
\item{\code{0}: }{N will not be computed.}
\item{\code{>0}: }{If any number >0 is provided,
that value will be set as N for every row.
\strong{Note}: Computing N this way is incorrect and should be avoided
if at all possible.}
\item{\code{"sum"}: }{N will be computed as:
cases (N_CAS) + controls (N_CON), so long as both columns are present}.
\item{\code{"ldsc"}: }{N will be computed as effective sample size:
Neff =(N_CAS+N_CON)*(N_CAS/(N_CAS+N_CON)) / mean((N_CAS/(N_CAS+N_CON))(N_CAS+N_CON)==max(N_CAS+N_CON))}.
\item{\code{"giant"}: }{N will be computed as effective sample size:
Neff = 2 / (1/N_CAS + 1/N_CON)}.
\item{\code{"metal"}: }{N will be computed as effective sample size:
Neff = 4 / (1/N_CAS + 1/N_CON)}.
}}

\item{credset_thresh}{The minimum mean Posterior Probability
(across all fine-mapping methods used) of SNPs to be included in 
the "mean.CS" column.}

\item{rescale_priors}{If prior probabilities are supplied,
rescale them from 0-1 (i.e. \code{rescaled_priors = priors / sum(priors)}).}

\item{force_new}{If saved results already exist in the given
\code{locus_dir}, skip re-running FINEMAP and use them 
(default: \code{force_new}). 
Set \code{TRUE} to ignore these files and re-run FINEMAP.}

\item{nThread}{Number of threads to parallelise across.
Passed to \code{"--n-threads"} in FINEMAP.}

\item{verbose}{Print messages.}

\item{...}{Additional arguments passed to the chosen 
fine-mapping \code{method}.}
}
\value{
The same input SNP-wise
 \code{dat} but with the following additional columns:
\itemize{
\item{"CS" : }{Credible Set of putative causal SNPs.}
\item{"PP" : }{Posterior (Inclusion) Probability of each SNP being causal, 
or belonging to the causal Credible Set.}
\item{"POLYFUN.h2" : }{The normalized heritability (h^2) used as  
prior probabilities during fine-mapping.} 
}
}
\description{
Uses echolocatoR wrapper for SUSIE instead of the \code{POLYFUN_finemapper}.
function which uses a python script provided with PolyFun.
}
\examples{
locus_dir <- file.path(tempdir(),echodata::locus_dir)
dat <- echodata::BST1
LD_matrix <- echodata::BST1_LD_matrix

dat2 <- echofinemap::POLYFUN(locus_dir=locus_dir,
                             dat=dat,
                             LD_matrix = LD_matrix,
                             method="SUSIE")
}
\seealso{
Other polyfun: 
\code{\link{POLYFUN_compute_priors}()},
\code{\link{POLYFUN_download_ref_files}()},
\code{\link{POLYFUN_find_polyfun_folder}()},
\code{\link{POLYFUN_finemapper}()},
\code{\link{POLYFUN_functional_enrichment}()},
\code{\link{POLYFUN_gather_annotations}()},
\code{\link{POLYFUN_gather_ldscores}()},
\code{\link{POLYFUN_h2_enrichment_SNPgroups_plot}()},
\code{\link{POLYFUN_h2_enrichment_SNPgroups}()},
\code{\link{POLYFUN_h2_enrichment}()},
\code{\link{POLYFUN_help}()},
\code{\link{POLYFUN_import_priors}()},
\code{\link{POLYFUN_initialize}()},
\code{\link{POLYFUN_ldsc_annot_enrichment}()},
\code{\link{POLYFUN_munge_summ_stats}()},
\code{\link{POLYFUN_plot}()},
\code{\link{POLYFUN_prepare_snp_input}()},
\code{\link{POLYFUN_run_ldsc}()}
}
\concept{polyfun}
