% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/POLYFUN.R
\name{POLYFUN}
\alias{POLYFUN}
\title{Run PolyFun+SUSIE fine-mapping pipeline}
\source{
\href{https://www.nature.com/articles/s41588-020-00735-5}{
PolyFun publication}

\href{https://github.com/omerwe/polyfun}{
PolyFun GitHub repo}
}
\usage{
POLYFUN(
  dat,
  LD_matrix,
  locus_dir,
  polyfun = NULL,
  mode = c("precomputed", "parametric", "non-parametric"),
  method = c("SUSIE", "FINEMAP"),
  dataset_type = "GWAS",
  max_causal = 5,
  sample_size = NULL,
  PP_threshold = 0.95,
  rescale_priors = TRUE,
  conda_env = "echoR",
  verbose = TRUE,
  ...
)
}
\arguments{
\item{dat}{GWAS summary statistics subset to query the LD panel with.}

\item{mode}{PolyFun can run in several different modes corresponding 
to how SNP-wise prior causal probabilities (i.e. priors) are computed:
\itemize{
\item{"precomputed" : }{
Using precomputed prior causal probabilities based on a meta-analysis of 
15 UK Biobank traits. The meta-analysis was performed as part of the 
original \href{https://www.nature.com/articles/s41588-020-00735-5}{
PolyFun publication}.}

\item{"parametric" : }{
Computing prior causal probabilities via an L2-regularized extension of 
stratified LD-score regression (S-LDSC). This is a relatively simple 
approach, but the prior causal probabilities may not be robust to modeling
 misspecification.
Gathered from the "*.snpvar_ridge_constrained.gz" output files from PolyFun}.

\item{"non-parametric" : }{
Computing prior causal probabilities non-parametrically. 
This is the most robust approach, but it is computationally intensive and
 requires access to individual-level genotypic data from a large reference 
 panel (optimally >10,000 population-matched individuals).
Gathered from the "*.snpvar_constrained.gz" output files from PolyFun}.
}}

\item{max_causal}{The maximum number of non-zero effects 
(and thus causal variants).}

\item{rescale_priors}{If prior probabilities are supplied,
rescale them from 0-1 (i.e. \code{rescaled_priors = priors / sum(priors)}).}

\item{verbose}{If \code{verbose = TRUE}, the algorithm's progress,
and a summary of the optimization settings, are printed to the
console.}

\item{...}{Additional arguments passed to the chosen 
fine-mapping \code{method}.}
}
\value{
The same input SNP-wise
 \code{dat} but with the following additional columns:
\itemize{
\item{"CS" : }{Credible Set of putative causal SNPs.}
\item{"PP" : }{Posterior (Inclusion) Probability of each SNP being causal, 
or belonging to the causal Credible Set.}
\item{"POLYFUN_h2" : }{The normalized heritability (h^2) used as  
prior probabilities during fine-mapping.} 
}
}
\description{
Uses echolocatoR wrapper for SUSIE instead of the \code{POLYFUN_finemapper}.
function which uses a python script provided with PolyFun.
}
\examples{
locus_dir <- file.path(tempdir(),echodata::locus_dir)
dat <- echodata::BST1
LD_matrix <- echodata::BST1_LD_matrix
dat2 <- echofinemap::POLYFUN_SUSIE(locus_dir=locus_dir, 
                                   dat=dat, 
                                   LD_matrix = LD_matrix)
}
\seealso{
Other polyfun: 
\code{\link{POLYFUN_compute_priors}()},
\code{\link{POLYFUN_download_ref_files}()},
\code{\link{POLYFUN_find_polyfun_folder}()},
\code{\link{POLYFUN_finemapper}()},
\code{\link{POLYFUN_functional_enrichment}()},
\code{\link{POLYFUN_gather_annotations}()},
\code{\link{POLYFUN_gather_ldscores}()},
\code{\link{POLYFUN_h2_enrichment_SNPgroups_plot}()},
\code{\link{POLYFUN_h2_enrichment_SNPgroups}()},
\code{\link{POLYFUN_h2_enrichment}()},
\code{\link{POLYFUN_help}()},
\code{\link{POLYFUN_import_priors}()},
\code{\link{POLYFUN_initialize}()},
\code{\link{POLYFUN_ldsc_annot_enrichment}()},
\code{\link{POLYFUN_munge_summ_stats}()},
\code{\link{POLYFUN_plot}()},
\code{\link{POLYFUN_prepare_snp_input}()},
\code{\link{POLYFUN_run_ldsc}()}
}
\concept{polyfun}
